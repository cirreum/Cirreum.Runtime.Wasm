@inject IMermaidService MermaidService
@implements IDisposable

<div @ref="containerRef" class="mermaid-container @CssClass" style="@Style">
	@if (IsLoading) {
		<div class="mermaid-loading">
			<div class="spinner"></div>
			<span>Rendering diagram...</span>
		</div>
	} else if (HasError) {
		<div class="mermaid-error">
			<strong>Diagram Error:</strong>
			<p>@ErrorMessage</p>
		</div>
	} else if (!string.IsNullOrEmpty(RenderedSvg)) {
		@((MarkupString)RenderedSvg)
	}
</div>

<style>
	.mermaid-container {
		width: 100%;
		overflow-x: auto;
		text-align: center;
	}

	.mermaid-loading {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 10px;
		padding: 2rem;
		color: #666;
	}

	.spinner {
		width: 20px;
		height: 20px;
		border: 2px solid #f3f3f3;
		border-top: 2px solid #007bff;
		border-radius: 50%;
		animation: spin 1s linear infinite;
	}

	@@keyframes spin {
		0% {
			transform: rotate(0deg);
		}
		100% {
			transform: rotate(360deg);
		}
	}

	.mermaid-error {
		background-color: #f8d7da;
		color: #721c24;
		padding: 1rem;
		border: 1px solid #f5c6cb;
		border-radius: 4px;
		text-align: left;
	}
</style>

@code {
	[Parameter] public string DiagramDefinition { get; set; } = string.Empty;

	/// <summary>
	/// Theme for the diagram. Use null or "auto" to automatically detect from Bootstrap theme.
	/// Explicit values: "default", "dark", "forest", "neutral", etc.
	/// </summary>
	[Parameter] public string? Theme { get; set; }

	[Parameter] public string CssClass { get; set; } = string.Empty;
	[Parameter] public string Style { get; set; } = string.Empty;
	[Parameter] public EventCallback<string> OnRendered { get; set; }
	[Parameter] public EventCallback<string> OnError { get; set; }

	private ElementReference containerRef;
	private string RenderedSvg = string.Empty;
	private bool IsLoading = false;
	private bool HasError = false;
	private string ErrorMessage = string.Empty;
	private string _lastRenderedDefinition = string.Empty;
	private string? _lastRenderedTheme;
	private bool _isSubscribed = false;
	private bool _isDisposed = false;

	protected override void OnInitialized() {
		// Subscribe to theme changes if using auto theme
		if (Theme == null || Theme == "auto") {
			MermaidService.ThemeChanged += OnThemeChanged;
			_isSubscribed = true;
		}
	}

	protected override async Task OnParametersSetAsync() {
		// Only re-render if the definition or theme actually changed
		if (DiagramDefinition != _lastRenderedDefinition || Theme != _lastRenderedTheme) {
			await RenderDiagramAsync();
		}
	}

	private void OnThemeChanged(string newTheme) {
		if (_isDisposed) return;

		// Re-render with the new theme
		InvokeAsync(async () => {
			if (!_isDisposed && !string.IsNullOrEmpty(DiagramDefinition)) {
				// Force re-render by clearing last rendered theme
				_lastRenderedTheme = null;
				await RenderDiagramAsync();
				StateHasChanged();
			}
		});
	}

	private async Task RenderDiagramAsync() {
		if (string.IsNullOrWhiteSpace(DiagramDefinition)) {
			RenderedSvg = string.Empty;
			return;
		}

		IsLoading = true;
		HasError = false;
		StateHasChanged();

		try {
			// Pass null/auto to let JS auto-detect Bootstrap theme
			var themeToUse = Theme == "auto" ? null : Theme;
			var svg = await MermaidService.RenderDiagramAsync(DiagramDefinition, themeToUse);
			RenderedSvg = svg;
			_lastRenderedDefinition = DiagramDefinition;
			_lastRenderedTheme = Theme;

			if (OnRendered.HasDelegate) {
				await OnRendered.InvokeAsync(svg);
			}
		} catch (Exception ex) {
			HasError = true;
			ErrorMessage = ex.Message;
			RenderedSvg = string.Empty;

			if (OnError.HasDelegate) {
				await OnError.InvokeAsync(ex.Message);
			}
		} finally {
			IsLoading = false;
			StateHasChanged();
		}
	}

	public void Dispose() {
		_isDisposed = true;
		if (_isSubscribed) {
			MermaidService.ThemeChanged -= OnThemeChanged;
		}
	}

}
